<html>

<head>
    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        
        attribute vec4 a_position;
        
        attribute vec4 color;
        attribute mat4 matrix;
    
        varying vec4 v_color;
    
        void main() {
            gl_Position = matrix * a_position;
    
            v_color = color;
        }
    </script>
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;
    
        varying vec4 v_color;
    
        void main() {
            gl_FragColor = v_color;
        }
    </script>
</head>

<body>
    <canvas id="canvas" style="width: 100vw; height: 100vh; display: block;"></canvas>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script>
        'use strict';

        function main() {
            /** @type {HTMLCanvasElement} */
            const canvas = document.querySelector('#canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                return;
            }

            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) {
                return alert('need ANGLE_instanced_arrays'); // eslint-disable-line
            }

            const program = webglUtils.createProgramFromScripts(
                gl, ['vertex-shader-3d', 'fragment-shader-3d']);

            const positionLoc = gl.getAttribLocation(program, 'a_position');
            const colorLoc = gl.getAttribLocation(program, 'color');
            const matrixLoc = gl.getAttribLocation(program, 'matrix');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -0.1, 0.4,
                -0.1, -0.4,
                0.1, -0.4,
                0.1, -0.4,
                -0.1, 0.4,
                0.1, 0.4,
                0.4, -0.1,
                -0.4, -0.1,
                -0.4, 0.1,
                -0.4, 0.1,
                0.4, -0.1,
                0.4, 0.1,
            ]), gl.STATIC_DRAW);
            const numVertices = 12;

            // setup matrices, one per instance
            const numInstances = 5;
            // make a typed array with one view per matrix
            const matrixData = new Float32Array(numInstances * 16);
            const matrices = [];
            for (let i = 0; i < numInstances; ++i) {
                const byteOffsetToMatrix = i * 16 * 4;
                const numFloatsForView = 16;
                matrices.push(new Float32Array(
                    matrixData.buffer,
                    byteOffsetToMatrix,
                    numFloatsForView));
            }

            const matrixBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
            // just allocate the buffer
            gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);

            // setup colors, one per instance
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array([
                    1, 0, 0, 1, // red
                    0, 1, 0, 1, // green
                    0, 0, 1, 1, // blue
                    1, 0, 1, 1, // magenta
                    0, 1, 1, 1, // cyan
                ]),
                gl.STATIC_DRAW);

            function render(time) {
                time *= 0.001; // seconds

                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.useProgram(program);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

                // update all the matrices
                matrices.forEach((mat, ndx) => {
                    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
                    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);
                });

                // upload the new matrix data
                gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);

                // 矩阵 设置
                const bytesPerMatrix = 4 * 16;
                for (let i = 0; i < 4; ++i) {
                    const loc = matrixLoc + i;
                    gl.enableVertexAttribArray(loc);
                    
                    // 每行 16字节
                    const offset = i * 16;
                    gl.vertexAttribPointer(
                        loc,      // location
                        4,        // 每行 4个浮点数
                        gl.FLOAT, // float
                        false,    // normalize
                        bytesPerMatrix, // stride, num bytes to advance to get to next set of values
                        offset,   // 相对 上面绑定 vbo 的 偏移
                    );
                    
                    // 每 1个实例 改变
                    ext.vertexAttribDivisorANGLE(loc, 1);
                }

                // set attribute for color
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.enableVertexAttribArray(colorLoc);
                gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
                
                // 每 1个实例 改变
                ext.vertexAttribDivisorANGLE(colorLoc, 1);
                
                // ext.drawElementsInstancedANGLE(
                //     gl.TRIANGLES,
                //     numIndices, // num indices per instance
                //     gl.UNSIGNED_SHORT,
                //     0, 
                //     numInstances, // num instances
                // );
                
                ext.drawArraysInstancedANGLE(
                    gl.TRIANGLES,
                    0, // offset
                    numVertices, // num vertices per instance
                    numInstances, // num instances
                );
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        main();
    </script>
</body>

</html>